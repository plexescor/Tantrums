================================================================================
                     TANTRUMS LANGUAGE — QUICK REFERENCE
================================================================================

Version  : 0.2.0
Extension: .42AHH  (source)  /  .42ass  (compiled bytecode)


================================================================================
HOW TO USE
================================================================================

  tantrums run <file.42AHH>       Compile to .42ass bytecode, then execute
  tantrums compile <file.42AHH>   Compile to .42ass only (no execution)
  tantrums exec <file.42ass>      Run a pre-compiled .42ass file

  Flags:
  --no-autofree-notes             Suppress auto-free compiler notes

The .42ass bytecode is cross-platform — compile on Windows, run on Linux
(as long as the Tantrums VM binary is compiled for that OS).


================================================================================
WHAT'S IMPLEMENTED (v0.2.0)
================================================================================

  [x] Variables              int x = 5;  or  x = 5;
  [x] Types                  int, float, string, bool, list, map
  [x] Functions              tantrum keyword, optional return type
  [x] Void functions         tantrum void foo()
  [x] Pointer return type    tantrum int* foo()
  [x] If / else if / else
  [x] While loop
  [x] For-in loop            for i in range(N), for i in list, for i in "string"
  [x] Loop control           break, continue
  [x] Operators              + - * / % == != < > <= >= => =< && || and or !
  [x] Compound assignment    i += 1, i -= 2, i *= 3, i /= 4, i %= 5
  [x] Increment/Decrement    i++, ++i, i--, --i
  [x] String escapes         \n \t \\ \" \r \0
  [x] Auto string concat     "age: " + 25 → "age: 25"
  [x] Type checking          compile-time type errors for typed params/vars
  [x] Mode directives        #mode static; / #mode dynamic; / #mode both;
  [x] Static return enforce  #mode static requires return types, void, all paths
  [x] Memory directives      #autoFree true/false, #allowMemoryLeaks true/false
  [x] Manual memory          alloc / free keywords
  [x] Pointer safety         null-check on deref, use-after-free, double-free detection
  [x] Escape analysis        smart compile-time pointer escape detection
  [x] Auto-free              compiler + runtime auto-free for provably local pointers
  [x] Leak detection         exit report with line numbers, types, sizes, memleaklog.txt
  [x] Comments               // single line,  /* multi-line */
  [x] Lists                  [1, 2, 3], indexing, append
  [x] Maps                   {"key": "value"}
  [x] Strings                treated as list of characters
  [x] Imports                use helper.42AHH;  (same directory only)
  [x] Built-in functions     print, input, len, range, type, append
  [x] Built-in profiling     getCurrentTime, getProcessMemory, bytesToMB, etc.
  [x] Throw                  throw "error message";
  [x] Try / Catch            try { ... } catch (e) { ... }, nested rethrow
  [x] Bytecode compiler      .42AHH → .42ass binary format
  [x] Cross-platform VM      runs .42ass on any OS
  [x] Entry point            main() function called automatically


================================================================================
WHAT'S TBD (future versions)
================================================================================

  [ ] Math module            use math;  (sin, cos, sqrt, pow, abs, floor, ceil)
  [ ] File system module     use fs;    (read, write, append, exists)
  [ ] C/C++ FFI              foreign "C" { ... }
  [ ] Graphics               OpenGL / Vulkan via modules
  [ ] Window creation        Win32 / GLFW / SDL2 wrapper
  [ ] Audio / Networking
  [ ] Native compilation     .42AHH → native .exe via LLVM
  [ ] JIT compiler           LLVM backend
  [ ] Package manager


================================================================================
SYNTAX REFERENCE
================================================================================

────────────────────────────────────────────────────────────────────────────────
FILE-LEVEL DIRECTIVES
────────────────────────────────────────────────────────────────────────────────

All directives must appear at the top of the file before any code.
Order matters: #mode → #autoFree → #allowMemoryLeaks

MODE DIRECTIVES:
  #mode static;     All variables must have type annotations.
                    All functions must declare return types.
                    All code paths must return.
                    x = 5; → COMPILE ERROR (missing type)
                    int x = 5; → OK

  #mode dynamic;    No type checking at all.
                    int x = "hello"; → OK (types ignored)

  #mode both;       Mixed mode (DEFAULT if no directive).
                    Typed variables are checked, untyped are dynamic.
                    int x = "hello"; → ERROR
                    x = "hello"; → OK

MEMORY DIRECTIVES:
  #autoFree true;   Default. Compiler + runtime auto-free pointers when safe.
                    Escape analysis runs on every pointer.
                    Provably local pointers are freed automatically.
                    Runtime catches anything the compiler missed.

  #autoFree false;  Full manual control. You free everything.
                    Compile-time auto-free disabled.
                    Runtime auto-free disabled.
                    Leak detector still reports what you forgot.
                    Runtime safety checks still active.

  #allowMemoryLeaks true;
                    Requires #autoFree false declared first.
                    Compile-time leak errors become warnings instead of aborting.
                    Program compiles and runs even with leaked pointers.
                    Exit leak report and runtime safety still active.
                    Use for arena/region allocation patterns.

  #allowMemoryLeaks false;
                    Default. Compile-time leak errors abort compilation.

VALID COMBINATIONS:
  (none)                          → #mode both, #autoFree true, leaks abort
  #mode static;                   → strict types, auto-free, leaks abort
  #autoFree false;                → manual memory, leaks abort
  #autoFree false;
  #allowMemoryLeaks true;         → manual memory, leaks warn only
  #autoFree true;
  #allowMemoryLeaks true;         → INVALID, compile error

────────────────────────────────────────────────────────────────────────────────
VARIABLES
────────────────────────────────────────────────────────────────────────────────

  x = 42;                    dynamic — no type needed
  int x = 42;                typed declaration
  float pi = 3.14;
  string name = "Tantrums";
  bool alive = true;
  list nums = [1, 2, 3];
  map data = {"name": "john", "age": "21"};

  // Defaults for unassigned typed declarations:
  list items;                → initializes as []
  map kv;                    → initializes as {}
  int y;                     → defaults to null

────────────────────────────────────────────────────────────────────────────────
FUNCTIONS
────────────────────────────────────────────────────────────────────────────────

  // With return type
  tantrum int add(int a, int b)
  {
      return (a + b);
  }

  // Void — no return value
  tantrum void greet(string name)
  {
      print("Hello " + name);
  }

  // Pointer return type
  tantrum int* makeValue()
  {
      int* p = alloc int(42);
      return (p);
  }

  // Dynamic — no types at all
  tantrum multiply(a, b)
  {
      return (a * b);
  }

  // #mode static rules for functions:
  //   - must declare return type (int, float, string, bool, list, map, void, int*)
  //   - non-void functions must have return statement
  //   - all code paths must return a value
  //   - return type must match declared type
  //   - void functions cannot return a value
  //   - void functions cannot be used in expressions

────────────────────────────────────────────────────────────────────────────────
CONTROL FLOW
────────────────────────────────────────────────────────────────────────────────

  if (x > 10)
  {
      print("big");
  }
  else if (x == 10)
  {
      print("ten");
  }
  else
  {
      print("small");
  }

  for i in range(10) { print(i); }         // 0 to 9
  for i in range(2, 10) { print(i); }      // 2 to 9
  for i in range(0, 50, 5) { print(i); }   // 0, 5, 10 ... 45
  for ch in "Hello" { print(ch); }         // H e l l o
  for item in [1, 2, 3] { print(item); }

  while (count > 0) { count--; }

  for i in range(10)
  {
      if (i == 5) { break; }
      if (i % 2 == 0) { continue; }
      print(i);
  }

────────────────────────────────────────────────────────────────────────────────
OPERATORS
────────────────────────────────────────────────────────────────────────────────

  Arithmetic:     +  -  *  /  %
                  "hello " + 42 → "hello 42"  (auto string concat)

  Comparison:     ==  !=  <  >  <=  >=  =>  =<
                  (=> and =< are reversed aliases for >= and <=)

  Logical:        &&  and    ||  or    !

  Compound:       +=  -=  *=  /=  %=

  Increment:      i++  ++i  i--  --i

  Pointer:        *p  (dereference)
                  &  is NOT supported (no address-of operator)

────────────────────────────────────────────────────────────────────────────────
MANUAL MEMORY
────────────────────────────────────────────────────────────────────────────────

  int* p = alloc int(42);    allocate an int on the heap
  print(*p);                 dereference to read → 42
  *p = 99;                   dereference to write
  free p;                    free the allocation

  Supported pointer operations:
    alloc type(value)        create pointer
    free p                   release pointer
    *p                       dereference (read or write)
    q = p                    alias — q points to same address
    foo(p)                   pass as argument
    return (p)               return from function (declared int*)
    append(list, p)          store in list
    map["key"] = p           store in map

  NOT supported:
    &x                       address-of — variables have no stable heap address
    p + 1                    pointer arithmetic
    (int*)p                  type casting

  Safety checks (always active regardless of directives):
    use-after-free           → [Tantrums Runtime Error] Null pointer dereference!
    double-free              → [Tantrums Runtime Error] Null pointer dereference!
    null dereference         → [Tantrums Runtime Error] Null pointer dereference!

  Escape analysis (with #autoFree true):
    if pointer is provably local (not returned, not passed, not aliased)
    → compiler inserts free automatically
    → emits: [Tantrums] note: auto-freed 'p' at line X (provably local)

  Escape conditions (compiler skips auto-free if ANY are true):
    1. pointer appears in a return statement
    2. pointer passed as function argument
    3. pointer passed to append()
    4. pointer assigned to another variable (alias)
    5. pointer stored in a map
    6. pointer assigned to a global variable
    7. pointer appears in any conditional branch
    8. pointer used in complex expression
    9. pointer used in more than one distinct way

────────────────────────────────────────────────────────────────────────────────
LEAK DETECTION
────────────────────────────────────────────────────────────────────────────────

  On program exit, if any alloc'd pointers were not freed:

  ≤5 leaks — printed to console:
    [Tantrums Warning] Memory leak detected: 3 allocation(s) not freed
      alloc at line 4 in main — int (96 bytes)
      alloc at line 7 in foo  — int (96 bytes)
      alloc at line 9 in main — int (96 bytes)
    Total Leaked Memory: 288 bytes = 0.28 KB

  >5 leaks — redirected to memleaklog.txt in same directory as .42ass:
    [Tantrums Warning] Memory leak detected: 47 allocation(s) not freed.
    See memleaklog.txt in the same directory as the executing bytecode.

  memleaklog.txt format:
    TANTRUMS MEMORY LEAK REPORT
    ============================
    Executable: main.42ass
    Leaks: 47 allocations
    ============================
      alloc at line 8 in main — int (96 bytes) [x47]
    ============================
    SUMMARY
      Total leaked: 4,512 bytes
                  = 4.41 KB
                  = 0.00 MB
                  = 0.00 GB
    ============================

────────────────────────────────────────────────────────────────────────────────
IMPORTS
────────────────────────────────────────────────────────────────────────────────

  use helper.42AHH;              import all functions from helper.42AHH
  use math_utils.42AHH;          same directory only

  Notes:
  - Duplicate imports are ignored
  - Circular imports are prevented
  - Imported functions available for type checking

────────────────────────────────────────────────────────────────────────────────
BUILT-IN FUNCTIONS
────────────────────────────────────────────────────────────────────────────────

  print(x)                   print any value to console
  input("prompt")            read line from user (return type depends on variable)
  len(x)                     length of string, list, or map
  range(end)                 list [0, 1, ..., end-1]
  range(start, end)          list [start, ..., end-1]
  range(start, end, step)    list [start, start+step, ..., < end]
  type(x)                    returns type name as string
  append(list, value)        appends value to list

  INPUT TYPE CASTING:
    x = input("prompt");           → string (default)
    string s = input("prompt");    → string
    int n = input("Enter num: ");  → parses as integer
    float f = input("Decimal: ");  → parses as float
    bool b = input("Yes? ");       → "true"→true, "false"→false,
                                     empty/whitespace→false, any other→true

  TIMING:
    getCurrentTime()               Unix epoch timestamp in milliseconds
    toSeconds(ms)                  convert ms to seconds (float)
    toMilliseconds(ms)             convert ms to milliseconds (float)
    toMinutes(ms)                  convert ms to minutes (float)
    toHours(ms)                    convert ms to hours (float)

  MEMORY PROFILING:
    getProcessMemory()             process RSS in bytes
    getVmMemory()                  Tantrums-managed heap in bytes
    getVmPeakMemory()              peak VM heap usage in bytes
    bytesToKB(bytes)               bytes → KB (float)
    bytesToMB(bytes)               bytes → MB (float)
    bytesToGB(bytes)               bytes → GB (float)

────────────────────────────────────────────────────────────────────────────────
ERROR HANDLING
────────────────────────────────────────────────────────────────────────────────

  throw "Something went wrong!";          halts with error message

  try
  {
      throw "oops";
  }
  catch (e)
  {
      print("Caught: " + e);
  }

  // Without error variable:
  try { throw "fail"; }
  catch { print("Something failed"); }

  // Nested with rethrow:
  try
  {
      try { throw "inner"; }
      catch (e)
      {
          print("Inner: " + e);
          throw "re-thrown";
      }
  }
  catch (e)
  {
      print("Outer: " + e);
  }

────────────────────────────────────────────────────────────────────────────────
STRING ESCAPE SEQUENCES
────────────────────────────────────────────────────────────────────────────────

  \n   newline
  \t   tab
  \\   backslash
  \"   double quote
  \r   carriage return
  \0   null character

────────────────────────────────────────────────────────────────────────────────
COMMENTS
────────────────────────────────────────────────────────────────────────────────

  // single-line comment
  /* multi-line
     comment */


================================================================================
COMPLETE EXAMPLE PROGRAMS
================================================================================

── BASIC ──────────────────────────────────────────────────────────────────────

  // fibonacci.42AHH
  tantrum int fib(int n)
  {
      if (n <= 1) { return (n); }
      return (fib(n - 1) + fib(n - 2));
  }

  tantrum void main()
  {
      for i in range(10) { print(fib(i)); }
  }

── MEMORY MANAGEMENT ──────────────────────────────────────────────────────────

  // manual.42AHH
  #autoFree false;

  tantrum int* makeNum(int val)
  {
      int* p = alloc int(val);
      return (p);
  }

  tantrum void main()
  {
      int* a = makeNum(42);
      int* b = makeNum(99);
      print(*a + *b);    // 141
      free a;
      free b;
  }

── STRICT STATIC TYPING ───────────────────────────────────────────────────────

  // strict.42AHH
  #mode static;

  tantrum int add(int a, int b)
  {
      return (a + b);
  }

  tantrum void main()
  {
      int result = add(10, 20);
      print(result);
  }

── PROFILING ──────────────────────────────────────────────────────────────────

  // bench.42AHH
  tantrum void main()
  {
      int start = getCurrentTime();

      int sum = 0;
      for i in range(1000000)
      {
          sum += i;
      }

      int end = getCurrentTime();
      print("Sum: " + sum);
      print("Time: " + toSeconds(end - start) + "s");
      print("RAM: " + bytesToMB(getProcessMemory()) + " MB");
  }

── ARENA ALLOCATION ───────────────────────────────────────────────────────────

  // arena.42AHH
  // Intentional arena pattern — allocate, use, let OS reclaim on exit
  #autoFree false;
  #allowMemoryLeaks true;

  tantrum void main()
  {
      int* a = alloc int(1);
      int* b = alloc int(2);
      int* c = alloc int(3);
      print(*a + *b + *c);    // 6
      // intentionally not freed — OS reclaims on exit
      // exit report will note 3 leaks with #allowMemoryLeaks true
  }


================================================================================
BUILD FROM SOURCE
================================================================================

  Requirements: CMake 3.15+, C++23 compiler (MSVC / GCC / Clang)

  # Release build (recommended — debug is ~2x slower)
  cmake -B build -S . -DCMAKE_BUILD_TYPE=Release
  cmake --build build --config Release

  # Run
  .\build\Release\tantrums.exe run your_program.42AHH

================================================================================