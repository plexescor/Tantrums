================================================================================
                      VARIABLES AND TYPES IN TANTRUMS
================================================================================

  Types. The eternal debate of programming. Should a language force you to
  declare every type like C++ (strict, safe, verbose)? Or should it let you
  do whatever you want like Python (flexible, fast to write, occasionally
  explodes at runtime)?

  Tantrums says: yes. Both. You decide. Per file. With one directive.

  This document covers:
  â€¢ The three typing modes and when to use each
  â€¢ How to declare variables with and without types
  â€¢ All built-in types in depth
  â€¢ Default initialization behavior
  â€¢ How values are stored in memory (and why it's 96 bytes per allocation)
  â€¢ The string rewrite that saved everything

================================================================================
  BASIC INFO: THE THREE MODES
================================================================================

  The first thing in any .42AHH file (before any code) can be a mode directive
  that tells the compiler how strict to be about types. There are three options.

  â”€â”€ #mode static â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  #mode static;

  Authoritarian mode. The compiler will not accept a single untyped variable.
  Everything must have an explicit type annotation. Every function must declare
  its return type. In #mode static, Tantrums behaves like a strict typed
  language â€” closer to C or Java than Python.

  Valid in #mode static:
  int x = 5;
  string name = "Tantrums";
  tantrum int add(int a, int b) { return (a + b); }
  tantrum void greet(string name) { print(name); }

  Invalid in #mode static (compile error):
  x = 5;             // ERROR: undeclared type, must be int x = 5;
  name = "hello";    // ERROR: undeclared type
  tantrum foo() { }  // ERROR: missing return type

  Additionally, in #mode static, the compiler enforces:
  â€¢ Every function MUST declare a return type (int, float, string, bool,
    list, map, void, or pointer types like int*)
  â€¢ Non-void functions MUST have a return statement in every code path
  â€¢ The returned value MUST match the declared return type
  â€¢ void functions CANNOT return a value
  â€¢ void functions CANNOT be used in expressions (x = voidFunc() is an error)

  Use #mode static when: You're writing library code, production systems,
  APIs, or anything where correctness matters more than write speed.

  â”€â”€ #mode dynamic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  #mode dynamic;

  The compiler takes a nap. In dynamic mode, type annotations are purely
  decorative. You can write `int x = "hello";` and the compiler will accept it
  without comment. Types are completely ignored during compilation. Everything
  behaves like Python â€” values can be any type, variables can hold anything,
  and all type errors happen at runtime (if at all).

  Valid in #mode dynamic (everything is valid):
  int x = "hello";       // compiler doesn't care
  x = [1, 2, 3];         // doesn't care
  x = true;              // still doesn't care
  tantrum foo() { }      // no return type required

  Use #mode dynamic when: You're prototyping, writing quick scripts, or doing
  exploratory programming where you'd rather move fast and fix later.

  â”€â”€ #mode both (default) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  #mode both;

  Or just don't write any directive at all. Both mode is the default.

  In both mode, the rules are simple:
  â€¢ If you annotate a variable with a type â†’ the compiler enforces it
  â€¢ If you don't annotate a variable â†’ it's dynamic, can hold anything

  This gives you the best of both worlds. You annotate the variables that matter
  (function parameters, return types, important data structures) and leave the
  rest dynamic. Most Tantrums code is written in both mode.

  int count = 0;         // typed â€” enforced
  count = "oops";        // COMPILE ERROR: cannot assign string to int
  count = 10;            // fine

  x = "whatever";        // dynamic â€” no type checking
  x = 42;                // fine
  x = [1, 2, 3];         // also fine

  Use #mode both when: You're writing general purpose programs where some things
  need to be strict and others don't. This is the sweet spot.

  â”€â”€ COMBINING MODES WITH OTHER DIRECTIVES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Mode directives combine with memory directives (#autoFree, #allowMemoryLeaks)
  to let you build four completely different programming environments:

  #mode static  + default autoFree    â†’ strict types, automatic memory safety
  #mode both    + default autoFree    â†’ flexible types, automatic memory safety (DEFAULT)
  #mode static  + #autoFree false     â†’ strict types, manual memory, like C with types
  #mode both    + #autoFree false     â†’ flexible types, full manual memory control

================================================================================
  BASIC INFO: DECLARING VARIABLES
================================================================================

  â”€â”€ DYNAMIC VARIABLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Dynamic variables have no type annotation. They can hold any value at any time.

  x = 42;
  x = "now it's a string";
  x = [1, 2, 3];
  x = true;

  All of that is valid. x just holds whatever you put in it. Under the hood,
  every variable is a Value struct that contains a type tag and a union of all
  possible value types. Changing x from int to string doesn't allocate new
  memory â€” it just changes the type tag in the Value struct.

  â”€â”€ TYPED VARIABLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Typed variables are declared with a type keyword before the name.

  int count = 10;
  float pi = 3.14159;
  string greeting = "Hello, World!";
  bool is_running = true;
  list numbers = [1, 2, 3, 4, 5];
  map config = {"host": "localhost", "port": "8080"};

  Once you declare a variable with a type, the compiler will reject any
  assignment that doesn't match. This check happens at compile time â€” your
  program won't even run if types don't match.

  int x = 42;
  x = 100;           // fine â€” 100 is an int
  x = "hello";       // COMPILE ERROR: cannot assign string to int
  x = 3.14;          // COMPILE ERROR: cannot assign float to int

  â”€â”€ POINTER VARIABLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Pointer variables are a special case covered in depth in memory_and_errors.txt.
  The short version:

  int* p = alloc int(42);    // p is a pointer to an int with value 42
  print(*p);                 // dereference to read the value: 42
  *p = 99;                   // dereference to write a new value
  free p;                    // release the allocation when done

  Pointers are only created via the alloc keyword. There is no address-of
  operator (&x) in Tantrums. Variables live in VM stack slots that don't have
  stable heap addresses, so &x would be meaningless or dangerous.

================================================================================
  BASIC INFO: BUILT-IN TYPES IN DEPTH
================================================================================

  â”€â”€ int â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Whole numbers. Positive, negative, or zero.

  int x = 42;
  int y = -100;
  int z = 0;

  Integers support all arithmetic operators: + - * / %
  Integer division truncates toward zero (no automatic float promotion).
  10 / 3 = 3, not 3.333...

  No size limit is enforced at the language level, but the underlying C++ type
  determines the actual limits (typically 64-bit signed integer range).

  â”€â”€ float â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Decimal numbers. Stored as double-precision floating point (64-bit IEEE 754).

  float pi = 3.14159;
  float e = 2.71828;
  float tiny = 0.001;

  Mixing int and float in arithmetic promotes the result to float:
  3 + 1.5 = 4.5

  When using typed parameters, int promotes to float automatically in function
  calls, so `tantrum float area(float r)` accepts integer arguments.

  â”€â”€ string â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Text. Stored as a dynamic buffer with automatic capacity doubling.

  string name = "Tantrums";
  string empty = "";
  string with_escapes = "Hello\nWorld\t!";

  Supported escape sequences:
  \n   newline
  \t   tab
  \\   literal backslash
  \"   literal double quote
  \r   carriage return
  \0   null character

  String concatenation with + automatically converts the other operand:
  "Score: " + 42            â†’ "Score: 42"
  "Value: " + 3.14          â†’ "Value: 3.14"
  "Active: " + true         â†’ "Active: true"

  Strings are iterable in for loops:
  for ch in "Hello" { print(ch); }  // prints H, then e, then l, then l, then o

  len() on a string returns the number of characters (not bytes, not UTF-8
  code points â€” characters as the VM understands them).

  â”€â”€ bool â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Boolean. Exactly two values: true or false.

  bool is_active = true;
  bool is_done = false;

  Tantrums is strict about booleans. The value in an if() condition MUST
  evaluate to a bool. You cannot use an integer, a string, or a list as a
  truthy/falsy condition. There is no implicit coercion to bool.

  Correct:   if (x > 0)            â†’ evaluates to bool via > operator
  Correct:   if (is_active)        â†’ is_active is already a bool
  Wrong:     if (x)                â†’ x is an int, not a bool, runtime error
  Wrong:     if (myList)           â†’ myList is a list, not a bool, runtime error

  If you want to check if a list is empty: if (len(myList) > 0)
  If you want to check if a variable is null: if (x != null)

  â”€â”€ list â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Ordered, mutable, dynamically-sized collections. Like Python lists.

  list nums = [1, 2, 3];
  list mixed = [1, "hello", true, [1, 2]];  // can hold anything
  list empty = [];

  Declaring list without assigning automatically initializes to []:
  list items;    // items is []

  Indexing: list[0] gets the first element, list[len(list) - 1] gets the last.
  There is no negative indexing (-1 for last element). Yet.

  append(myList, value) adds a value to the end. This mutates the list directly.

  Lists can be nested arbitrarily:
  list matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

  Iteration:
  for item in myList { print(item); }

  The iterator takes a snapshot of the list before the loop. Modifying the list
  during iteration (appending, removing) is safe and will not corrupt the loop.
  Changes made during iteration just won't be reflected in that loop's iteration.

  â”€â”€ map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Key-value pairs. Like Python dictionaries or JavaScript objects.

  map config = {"host": "localhost", "port": "8080"};
  map scores = {"Alice": 95, "Bob": 87};
  map empty_map;    // automatically initializes to {}

  Accessing a value: config["host"]  â†’ "localhost"
  Setting a value:   config["timeout"] = 30

  Keys are strictly typed. The integer key 1 and the string key "1" are
  completely different keys. This is intentional â€” Tantrums refuses to do
  JavaScript's infamous implicit string coercion for dictionary keys.

  Maps can hold any value type, including lists, other maps, and pointers.

  â”€â”€ void â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void is a return type, not a value type. It means "this function doesn't
  return anything."

  tantrum void greet(string name)
  {
      print("Hello, " + name + "!");
  }

  void functions can have empty return statements (return;) but cannot return
  values. In #mode static, calling a void function in an expression is an error:

  x = greet("World");    // ERROR in #mode static: void has no return value
  greet("World");         // fine â€” called as a statement

================================================================================
  ADVANCED INFO: DEFAULT INITIALIZATION
================================================================================

  What happens if you declare a typed variable but don't assign anything?

  In C and C++, uninitialized variables contain whatever garbage happened to
  be in that memory location. This is the source of countless bugs and security
  vulnerabilities.

  In Tantrums, variables you declare without assigning get safe defaults:

  int x;         â†’ null (prints as null, won't cause a crash)
  float f;       â†’ null
  string s;      â†’ null
  bool b;        â†’ null
  list items;    â†’ []     (empty list, not null)
  map data;      â†’ {}     (empty map, not null)

  The list and map defaults are especially important. You can declare a list
  at the top of a function and immediately start appending to it without any
  initialization ceremony.

  tantrum void collectData()
  {
      list results;                    // automatically []
      append(results, "first item");   // works immediately
      append(results, "second item");
      print(results);                  // [first item, second item]
  }

================================================================================
  ADVANCED INFO: HOW VALUES WORK UNDER THE HOOD
================================================================================

  Every value in the VM â€” whether it's an integer, a string, a list, a pointer,
  or a boolean â€” is stored as a Value struct in C++.

  The Value struct looks roughly like this (simplified):

  struct Value {
      ValueType type;    // an enum: VAL_INT, VAL_FLOAT, VAL_STRING, etc.
      union {
          long long  as_int;
          double     as_float;
          bool       as_bool;
          StringObj* as_string;
          ListObj*   as_list;
          MapObj*    as_map;
          void*      as_pointer;
      };
  };

  This is why every alloc'd pointer currently takes 96 bytes â€” the Value struct
  includes the type enum, the union (which must be large enough for the largest
  member), alignment padding, and malloc block headers. It's not 4 bytes for
  an integer like in C because everything in Tantrums is a full Value, not a
  raw primitive.

  We originally attempted NaN-boxing â€” the technique used by LuaJIT and V8 to
  pack all value types into a single 64-bit double. The idea is elegant: IEEE 754
  doubles have billions of NaN bit patterns that are never used as actual numbers.
  You can stuff pointers, booleans, and integers into those unused NaN patterns
  and use the sign bit to distinguish types.

  We tried it. It immediately resulted in horrifying undefined behavior from
  bit-shifting floating point values in C++. We gave up within a few hours and
  went back to the comfortable enum + union approach.

  The tradeoff: we use more memory per value (96 bytes vs theoretical 8 bytes),
  but the code is readable and the VM doesn't randomly corrupt data. We optimized
  for developer sanity. The performance is still 8-11x faster than Python, so
  the extra memory overhead didn't hurt us where it counts.

================================================================================
  LAUGHS & FACTS: THE STRING CATASTROPHE AND COMEBACK
================================================================================

  ðŸ§µ THE ORIGINAL STRING IMPLEMENTATION
  Strings in the first version of Tantrums were implemented as list objects.
  An actual Tantrums list where each element was a one-character string.

  So "hello" was stored as: ["h", "e", "l", "l", "o"]

  This meant:
  â€¢ Constructing "hello" required 6 memory allocations (5 chars + the list)
  â€¢ Concatenating two strings required building a new list
  â€¢ len("hello") iterated the list to count elements
  â€¢ Every string operation was O(n) where it should be O(1)

  A 200,000 character string concatenation test took over 100 seconds.
  Python did it in under a second. A language supposed to be faster than Python
  was 100x slower at strings. This was considered suboptimal.

  ðŸ§µ THE REWRITE
  The entire string implementation was torn out and replaced with a proper
  dynamic buffer: a char* data pointer with explicit length and capacity fields,
  geometric doubling when capacity is exceeded, and O(1) amortized appends.

  After the rewrite, that same 200,000 character test took 18 milliseconds.
  From 100 seconds to 0.018 seconds. A 5,500x speedup from one architectural fix.

  This is also why the documentation says "strings are treated as a list of
  characters" in some older files â€” that used to be literally true. It's no
  longer true. It's a historical artifact that survived into the docs.

  ðŸ§µ THE JAVASCRIPT COERCION REFUSAL
  JavaScript has a famous feature where adding an empty array to an object gives
  you "[object Object]" and adding two empty arrays gives you an empty string.
  This is because JavaScript coerces everything to strings for the + operator,
  which was probably a reasonable idea in 1995 that became a running joke.

  Tantrums specifically refused to implement this. The + operator between two
  non-string, non-numeric types is a type error. But if ONE side is a string,
  the other side gets converted automatically. "Score: " + 42 = "Score: 42".
  That's helpful. [] + {} = crash. That's honest.

  ðŸ§µ THE TRUTHY COERCION REFUSAL
  In JavaScript: if ([]) evaluates to true. An empty array is truthy.
  In Python: if []: evaluates to false. An empty list is falsy.
  These two languages disagree on what "empty collection" means as a boolean.

  Tantrums refuses to play this game. if() requires a bool. Period. if(myList)
  is a runtime error. Write what you mean: if (len(myList) > 0).
  The extra characters are worth the clarity.

  ðŸ§µ THE MAP KEY TYPING
  In JavaScript, ALL object keys are strings. If you use an integer as a key
  (obj[1] = "value"), JavaScript silently converts it to the string "1".
  So obj[1] and obj["1"] access the same slot.

  Tantrums map keys are full Value structs. The integer 1 and the string "1"
  are hashed differently and live in completely different buckets. They are
  different keys. What you put in is what you get back. No silent coercion.

================================================================================
  END OF VARIABLES AND TYPES. PICK YOUR MODE. DECLARE YOUR VARIABLES.
  MAY YOUR TYPES ALWAYS MATCH.
================================================================================