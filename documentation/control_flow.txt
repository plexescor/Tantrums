================================================================================
                          CONTROL FLOW IN TANTRUMS
================================================================================

  A program that only runs top-to-bottom isn't very useful. You need branches.
  You need loops. You need the ability to make decisions and repeat things.
  That's what control flow is â€” the art of making your code go somewhere
  other than straight down.

  Tantrums has all the standard tools plus a few quirks that are either
  genuinely clever or moderately chaotic depending on how you look at them.

  This document covers:
  â€¢ if / else if / else â€” branching
  â€¢ while loops â€” condition-based repetition
  â€¢ for-in loops â€” iterating over ranges, lists, and strings
  â€¢ break and continue â€” loop control
  â€¢ All operators â€” arithmetic, comparison, logical
  â€¢ The reversed operator aliases (=> and =<) and why they exist
  â€¢ Short-circuit evaluation and how it saves CPU cycles
  â€¢ The strict boolean requirement and what it means for you

================================================================================
  BASIC INFO: BRANCHING WITH IF / ELSE
================================================================================

  The if statement evaluates a condition and executes a block if it's true.

  if (x > 10)
  {
      print("X is greater than 10.");
  }

  Add an else block for the false case:

  if (x > 10)
  {
      print("X is big.");
  }
  else
  {
      print("X is not big.");
  }

  Chain multiple conditions with else if:

  if (x > 100)
  {
      print("Very big.");
  }
  else if (x > 10)
  {
      print("Moderately big.");
  }
  else if (x > 0)
  {
      print("A little big.");
  }
  else
  {
      print("Not big at all, or negative.");
  }

  The conditions are evaluated top to bottom. The first one that's true wins
  and its block executes. The rest are skipped. If none are true, the else
  block runs (if one exists).

  â”€â”€ IMPORTANT: THE BOOLEAN REQUIREMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  The condition inside if() MUST evaluate to a bool type. Not an int. Not a
  string. Not a list. A boolean.

  This means you cannot write:
  if (myList)           // ERROR: myList is a list, not a bool
  if (x)                // ERROR: x is an int, not a bool
  if ("text")           // ERROR: "text" is a string, not a bool

  You must be explicit:
  if (len(myList) > 0)  // CORRECT: comparison returns bool
  if (x != 0)           // CORRECT: comparison returns bool
  if (is_active)        // CORRECT: is_active is already a bool

  Comparison operators (==, !=, <, >, <=, >=) always return bool.
  Logical operators (and, or, !) always return bool.
  Boolean variables are bool.
  Everything else is not a bool.

  Why is Tantrums strict about this? Because implicit truthy/falsy coercion
  is the source of countless subtle bugs. In JavaScript, an empty array []
  is truthy in if statements. In Python, an empty list [] is falsy. These two
  languages disagree on what "empty" means as a condition, and both conventions
  are confusing to people coming from the other language.

  Tantrums refuses to have a convention. Write what you mean. Be explicit.
  The extra few characters are worth it.

================================================================================
  BASIC INFO: WHILE LOOPS
================================================================================

  while loops repeat a block as long as a condition is true.

  int count = 5;
  while (count > 0)
  {
      print(count);
      count--;
  }
  // prints: 5, 4, 3, 2, 1

  The condition is checked before each iteration. If it's false on the first
  check, the body never executes. If you never make the condition false inside
  the loop, you get an infinite loop.

  while (true)
  {
      string input = input("Type 'quit' to exit: ");
      if (input == "quit") { break; }
      print("You said: " + input);
  }

  The above is a valid pattern â€” loop forever, use break to escape when needed.

  The same boolean requirement applies. The while() condition must be a bool.

================================================================================
  BASIC INFO: FOR-IN LOOPS â€” THREE VARIANTS
================================================================================

  Tantrums has three variants of the for-in loop, each optimized for a
  different use case. They all use the same syntax but iterate over different things.

  â”€â”€ VARIANT 1: RANGE-BASED ITERATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  for i in range(10)
  {
      print(i);
  }
  // prints 0 through 9

  range() generates a sequence of integers. See functions.txt for the full
  three-form range signature (range(end), range(start, end), range(start, end, step)).

  The critically important detail: the compiler does NOT actually create a list
  of 10 integers in memory for range(10). Instead, the compiler generates
  specialized loop bytecode:
  â€¢ Initialize a counter variable to 0 (or start)
  â€¢ Before each iteration: compare counter to 10 (or end), exit if equal
  â€¢ At end of each iteration: add step to counter, loop back

  This means range(1000000000) does NOT require 1 billion integers in memory.
  It uses exactly the same amount of memory regardless of the range size â€”
  just the counter variable. This is why tight integer loops in Tantrums are
  so fast (11x faster than Python on the benchmark).

  â”€â”€ VARIANT 2: LIST ITERATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  list fruits = ["apple", "banana", "cherry"];
  for fruit in fruits
  {
      print(fruit);
  }
  // prints: apple, banana, cherry

  Or with a literal list:
  for n in [1, 4, 9, 16, 25]
  {
      print(n);
  }

  The compiler takes a snapshot of the list before the loop begins. If you
  modify the list during iteration (appending, changing values), the iteration
  continues over the original snapshot. This prevents the classic "modified
  collection during iteration" crash that trips up many developers.

  tantrum main()
  {
      list nums = [1, 2, 3];
      for n in nums
      {
          append(nums, n * 10);    // safe â€” modifies the list but not the iterator
          print(n);                // still prints 1, 2, 3 in order
      }
      print(nums);    // [1, 2, 3, 10, 20, 30] â€” modifications are there
  }

  â”€â”€ VARIANT 3: STRING ITERATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  for ch in "Hello"
  {
      print(ch);
  }
  // prints: H, then e, then l, then l, then o (each on its own line)

  String iteration pulls each character out one at a time. Each ch is a
  one-character string. You can treat it like any other string â€” concatenate
  it, compare it, pass it to functions.

  Counting vowels example:
  int vowels = 0;
  string text = "Tantrums is a great language";
  for ch in text
  {
      if (ch == "a" or ch == "e" or ch == "i" or ch == "o" or ch == "u")
      {
          vowels++;
      }
  }
  print("Vowels: " + vowels);

================================================================================
  BASIC INFO: BREAK AND CONTINUE
================================================================================

  break exits the innermost loop immediately, skipping any remaining iterations.

  for i in range(10)
  {
      if (i == 5) { break; }
      print(i);
  }
  // prints 0, 1, 2, 3, 4 â€” stops when i hits 5

  continue skips the rest of the current iteration and jumps to the next one.

  for i in range(10)
  {
      if (i % 2 == 0) { continue; }  // skip even numbers
      print(i);
  }
  // prints 1, 3, 5, 7, 9

  break and continue work in both for-in loops and while loops.

  Both keywords work by manipulating the VM's Instruction Pointer (IP). When
  the compiler sees a break, it emits an unconditional jump to the first
  instruction after the loop. When it sees a continue, it emits a jump to
  the loop's increment/check point. The offsets are calculated during
  compilation â€” by the time the VM runs, it's just a jump with a fixed target.

================================================================================
  ADVANCED INFO: THE FULL OPERATOR CATALOG
================================================================================

  â”€â”€ ARITHMETIC OPERATORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  +    addition, also string concatenation (if either side is a string)
  -    subtraction
  *    multiplication
  /    division (truncates for int/int, produces float if either is float)
  %    modulo (remainder after division)

  Examples:
  10 + 3      â†’ 13
  10 - 3      â†’ 7
  10 * 3      â†’ 30
  10 / 3      â†’ 3     (integer division, truncated)
  10.0 / 3    â†’ 3.333...  (float division because 10.0 is a float)
  10 % 3      â†’ 1

  "hello" + " world"    â†’ "hello world"
  "count: " + 42        â†’ "count: 42"    (int auto-converts to string)

  â”€â”€ COMPARISON OPERATORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  ==    equal to
  !=    not equal to
  <     less than
  >     greater than
  <=    less than or equal to
  >=    greater than or equal to
  =<    alias for <=   (reversed â€” valid in Tantrums)
  =>    alias for >=   (reversed â€” valid in Tantrums)

  All comparison operators return bool.

  5 == 5     â†’ true
  5 != 3     â†’ true
  5 < 3      â†’ false
  5 > 3      â†’ true
  5 <= 5     â†’ true
  5 >= 6     â†’ false
  5 =< 5     â†’ true   (same as 5 <= 5)
  5 => 3     â†’ true   (same as 5 >= 3)

  â”€â”€ LOGICAL OPERATORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  &&     logical AND (both sides must be true)
  and    alias for &&
  ||     logical OR (at least one side must be true)
  or     alias for ||
  !      logical NOT (inverts a bool)

  true && true    â†’ true
  true && false   â†’ false
  true || false   â†’ true
  false || false  â†’ false
  !true           â†’ false
  !false          â†’ true

  The `and` and `or` keywords are provided because they're more readable in
  complex conditions. Both forms work identically.

  if (x > 0 and x < 100) { }    // same as if (x > 0 && x < 100)
  if (done or failed) { }        // same as if (done || failed)

  â”€â”€ COMPOUND ASSIGNMENT OPERATORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  +=    add and assign:      i += 5  is i = i + 5
  -=    subtract and assign: i -= 3  is i = i - 3
  *=    multiply and assign: i *= 2  is i = i * 2
  /=    divide and assign:   i /= 4  is i = i / 4
  %=    modulo and assign:   i %= 3  is i = i % 3

  These are pure syntactic sugar. The compiler generates the exact same AST
  for i += 5 as it does for i = i + 5. There's no performance difference.
  They just save you from typing the variable name twice.

  â”€â”€ INCREMENT AND DECREMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  i++    post-increment: returns i, then increments i
  ++i    pre-increment: increments i, then returns i
  i--    post-decrement: returns i, then decrements i
  --i    pre-decrement: decrements i, then returns i

  In standalone statements, all four do the same thing. The difference matters
  in expressions:

  int i = 5;
  print(i++);    // prints 5, then i becomes 6
  print(++i);    // i becomes 7, then prints 7

================================================================================
  ADVANCED INFO: THE REVERSED OPERATORS â€” => AND =<
================================================================================

  This is one of Tantrums' most unusual features, and also one of the most
  loved once people understand it.

  Standard comparison operators:  >=   <=
  Reversed aliases in Tantrums:   =>   =<

  They are identical in behavior. `x >= 5` and `x => 5` produce the same
  bytecode and the same result.

  Why do these exist? Because developers make typos. When you're typing fast,
  it's completely natural to type => instead of >= â€” especially if you're
  coming from a language where => means something (JavaScript, Haskell, etc.).

  In most languages:
  â€¢ JavaScript: => creates an arrow function. a => 5 is a function, not a comparison.
  â€¢ C++: => is a syntax error. The compiler screams.
  â€¢ Tantrums: => is just >=. Keeps working. You'll never know you made a typo.

  Same for =<. In most languages, =< is a syntax error. In Tantrums, it's <=.

  We call these the "fat-finger operators." They exist because the Tantrums
  lexer was explicitly built to handle the most common directional mistakes
  when typing comparison operators at speed. It's not a design compromise â€”
  it's a deliberate ergonomic feature.

  if (x => 0 and x =< 100)    // valid Tantrums, same as x >= 0 && x <= 100
  {
      print("x is in range");
  }

================================================================================
  ADVANCED INFO: SHORT-CIRCUIT EVALUATION
================================================================================

  Tantrums implements short-circuit evaluation for && (and) and || (or).
  This is an optimization that skips evaluating the right side of a logical
  operator when the result is already determined by the left side.

  For &&: if the left side is false, the whole expression is false regardless
  of the right side. So the right side is never evaluated.

  if (false && expensiveFunction())
  {
      // never reached
  }
  // expensiveFunction() is NEVER CALLED â€” the VM sees `false &&` and jumps
  // past the entire expression immediately

  For ||: if the left side is true, the whole expression is true regardless
  of the right side. So the right side is never evaluated.

  if (true || expensiveFunction())
  {
      // always reached
  }
  // expensiveFunction() is NEVER CALLED

  This matters beyond performance. It's how you safely check things that could
  crash if evaluated unconditionally:

  // Check if list is non-empty before accessing first element
  if (len(items) > 0 and items[0] == "target")
  {
      print("found");
  }

  If items is empty, len(items) > 0 is false, and items[0] is never evaluated.
  No out-of-bounds access. Short-circuit evaluation makes this pattern safe.

  The VM implements this by emitting OP_JUMP_IF_FALSE and OP_JUMP_IF_TRUE
  opcodes at the point where the short-circuit can occur. If the early-exit
  condition is met, the IP jumps past the rest of the expression.

================================================================================
  ADVANCED INFO: HOW JUMP OFFSETS WORK
================================================================================

  Every if statement, while loop, and for loop involves jumps â€” the VM's
  Instruction Pointer moving to a different location in the bytecode.

  The compiler handles this in two phases:

  Phase 1 (when it first sees the if/loop): The compiler emits a jump opcode
  with a placeholder offset (usually 0). It records the position of this
  placeholder.

  Phase 2 (when it reaches the end of the block): The compiler now knows
  how many bytes of bytecode the block contained. It goes back and patches
  the placeholder with the real offset.

  This is called "backpatching" and it's standard practice in bytecode compilers.

  The operand for jump opcodes is a signed integer. The maximum jump offset
  is bounded by this integer's range. If you write an if statement with an
  astronomically large block (tens of thousands of lines of code inside a single
  branch), you could theoretically exceed the maximum representable jump offset.
  In practice, no real program does this. But theoretically, if you tried to
  put 65,535+ bytes of bytecode inside a single branch, the compiler would fail.
  This has never happened in practice.

================================================================================
  LAUGHS & FACTS: THE CONTROL FLOW EDITION
================================================================================

  ðŸ”€ THE SWITCH STATEMENT THAT NEVER WAS
  There are no switch statements in Tantrums. The reason is embarrassingly
  honest: implementing switch in a bytecode compiler requires building a jump
  table â€” a data structure that maps each case value to the bytecode offset of
  that case's block. Computing jump tables in C++ requires careful bookkeeping
  of offsets that aren't known until the entire switch block is parsed.

  The developers looked at the complexity, looked at the deadline, and decided
  that long chains of else if are perfectly fine. They are, technically. They
  compile to sequential comparisons rather than a jump table, which is slightly
  slower for large switches, but for the sizes most switch statements actually
  are, the difference is negligible.

  switch statements are on the roadmap. Probably.

  ðŸ”€ THE RANGE OPTIMIZATION THAT SURPRISED EVERYONE
  When the decision was made that range(N) in for loops would generate
  specialized loop bytecode rather than allocating a list, nobody was sure how
  much it would help. The answer, on the 100 million iteration benchmark, was:
  a lot. The loop runs in 4.26 seconds. Python takes 46.86 seconds for the
  same loop. That 11x speedup comes almost entirely from not allocating a
  100 million element list just to iterate it.

  Python actually uses the same optimization internally with its range object.
  We just made the same decision independently and were pleased to discover
  we'd arrived at the same conclusion as the Python developers.

  ðŸ”€ THE LIST ITERATOR SNAPSHOT
  The decision to snapshot the list before iterating was made after a bug where
  modifying a list during iteration caused the iterator to skip elements or
  revisit them depending on where the modification happened. Rather than
  implementing complex "concurrent modification" detection, the solution was
  to just take a snapshot at the start. Simple. Predictable. Correct.

  ðŸ”€ THE FAT-FINGER ORIGIN STORY
  The reversed operators (=> and =<) were added after a user spent 20 minutes
  debugging code that looked perfectly correct but kept getting syntax errors.
  The problem was that they'd typed => everywhere instead of >=. The fix was
  to just make => valid. Instead of making the user change their habits,
  the language adapted to the user. This is the correct philosophy.

  ðŸ”€ THE COMPOUND ASSIGNMENT REVELATION
  When += and -= were implemented, the developers discovered that the cleanest
  way to handle them was to have the parser transform `i += 5` into the AST for
  `i = i + 5` at parse time. The code generator then never needed to know about
  compound assignment at all. The transformation is invisible by the time
  bytecode is generated. Two lines of parser code, zero lines of VM code.

================================================================================
  END OF CONTROL FLOW. BRANCH WISELY. LOOP EFFICIENTLY.
  MAY ALL YOUR CONDITIONS EVALUATE TO BOOL.
================================================================================