================================================================================
                          FUNCTIONS IN TANTRUMS
================================================================================

  Functions are the building blocks of every program. Every language has them.
  Every language declares them differently. Python uses `def`. JavaScript uses
  `function`. Rust uses `fn`. Go uses `func`.

  Tantrums uses `tantrum`.

  Why? Because every function you've ever written in any language is a tantrum.
  "DO THIS THING. IN THIS EXACT ORDER. WITH THESE EXACT INPUTS. AND GIVE ME
  BACK EXACTLY WHAT I EXPECT OR I WILL CRASH." That's a tantrum. We're just
  honest about it.

  This document covers:
  â€¢ Basic function declaration â€” all forms
  â€¢ Return types including void and pointer returns
  â€¢ Parameters â€” typed, untyped, mixed
  â€¢ How the call stack works
  â€¢ Imports and multi-file programs
  â€¢ Every built-in function in detail
  â€¢ Weird behaviors worth knowing about

================================================================================
  BASIC INFO: DECLARING A FUNCTION
================================================================================

  The general form of a function declaration:

  tantrum returnType functionName(paramType paramName, ...)
  {
      // body
      return (value);
  }

  returnType and paramTypes are optional depending on your #mode directive.
  Let's look at every variation.

  â”€â”€ FULLY TYPED FUNCTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  tantrum int add(int a, int b)
  {
      return (a + b);
  }

  This declares a function named add that takes two ints and returns an int.
  The compiler validates that:
  â€¢ Callers pass two arguments
  â€¢ Both arguments are ints (or int-compatible types)
  â€¢ The function returns an int (not a string, not a bool)

  Notice that return requires parentheses around the value: return (a + b),
  not return a + b. This is a Tantrums syntax requirement. The parentheses
  are not optional.

  â”€â”€ VOID FUNCTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  tantrum void greet(string name)
  {
      print("Hello, " + name + "!");
  }

  void means "this function doesn't return a value." Void functions:
  â€¢ Can have empty return statements (return;) â€” just exits the function
  â€¢ Cannot return a value (return (42); is a compile error)
  â€¢ Cannot be used in expressions in #mode static (x = greet("World") is an error)

  When you're in #mode static, every function must declare a return type.
  If you don't declare one, the compiler refuses to compile. Use void for
  functions that genuinely return nothing.

  â”€â”€ DYNAMIC / UNTYPED FUNCTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  tantrum multiply(a, b)
  {
      return (a * b);
  }

  No return type. No parameter types. Everything is dynamic. This works in
  #mode both and #mode dynamic. In #mode static, this is a compile error
  because the return type is missing.

  Dynamic functions are checked for argument count at runtime (calling with
  wrong number of arguments causes a runtime error) but not for argument types.

  â”€â”€ PARTIALLY TYPED FUNCTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  tantrum greet(string name)
  {
      print("Hello, " + name);
  }

  No return type (implicitly dynamic/void), but the parameter is typed.
  The compiler will enforce that callers pass a string for name, but won't
  enforce a return type. Valid in #mode both.

  â”€â”€ POINTER RETURN TYPE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  tantrum int* makeValue()
  {
      int* p = alloc int(42);
      return (p);
  }

  This function returns a pointer to an int. The * in the return type tells
  the compiler and the caller that this function's return value is a pointer.

  The caller receives a pointer:
  int* v = makeValue();
  print(*v);    // 42
  free v;       // caller is responsible for freeing it

  When a function returns a pointer, the compiler's escape analysis
  automatically marks that pointer as escaped â€” it will NOT emit a leak
  error for it, and will NOT auto-free it. The calling code takes ownership.

  â”€â”€ COMPLETE EXAMPLE WITH ALL FORMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  tantrum int* allocate(int value)           // pointer return, typed params
  {
      int* p = alloc int(value);
      return (p);
  }

  tantrum void process(int* p)              // void return, pointer param
  {
      *p = *p * 2;
      print("Processed: " + *p);
  }

  tantrum int readValue(int* p)             // typed return, pointer param
  {
      return (*p);
  }

  tantrum main()
  {
      int* ptr = allocate(21);
      process(ptr);                          // ptr is now 42
      int val = readValue(ptr);
      print(val);                            // 42
      free ptr;
  }

================================================================================
  BASIC INFO: CALLING FUNCTIONS
================================================================================

  Functions are called exactly like C or Python:

  functionName(arg1, arg2, arg3);

  Nothing special. Arguments are evaluated left to right before the call.
  The return value can be used in expressions or discarded.

  print(add(10, 20));          // use return value immediately
  int result = add(10, 20);    // store return value
  add(10, 20);                 // discard return value (fine)

  One thing to note: if a function returns a pointer and you discard it,
  the compiler with #autoFree true will emit a warning:
  [Tantrums Warning] pointer return value discarded â€” potential leak

  â”€â”€ THE main() FUNCTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Every Tantrums program needs a main() function. It's the entry point â€” the
  first thing the VM calls when your program starts.

  tantrum main()         // or tantrum void main()
  {
      // your program starts here
  }

  Without main(), the program compiles successfully but does absolutely nothing
  when you run it. The VM looks for main, finds nothing, and exits in effectively
  zero milliseconds. No error. No output. Just silence. This confused many early
  users, which is why the VS Code extension has a specific diagnostic for it.

================================================================================
  ADVANCED INFO: THE CALL STACK
================================================================================

  Every time a function is called, the VM creates a new Call Frame. A Call Frame
  contains:
  â€¢ The function's local variables (in an indexed array of Value slots)
  â€¢ The instruction pointer (which bytecode instruction to execute next)
  â€¢ The return address (where to go when the function returns)
  â€¢ The scope depth tracker (for runtime auto-free of pointers)

  Call Frames are stacked. When main() calls add(), the stack looks like:
  [ main() frame ] [ add() frame ]

  When add() returns, its frame is popped and main() resumes from where it left
  off. When main() returns, its frame is popped and execution ends.

  The call stack supports up to 16,384 frames deep. If you write a recursive
  function without a proper base case, you'll consume all 16,384 frames and
  get a clean "Stack Overflow" error from the VM â€” not a catastrophic OS-level
  crash. The VM panics gracefully and tells you exactly what happened.

  16,384 deep is generous for most programs, but be aware: Tantrums currently
  has no tail-call optimization. A recursive Fibonacci for large values will
  eat through call frames quickly. For anything that needs deep recursion,
  convert it to an iterative loop.

  â”€â”€ HOW ARGUMENTS ARE PASSED â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Arguments in Tantrums are passed by value. When you call add(x, y), the VM
  copies the values of x and y into the new call frame's local variable slots.
  Modifying a parameter inside a function does NOT modify the original variable.

  tantrum void double(int n)
  {
      n = n * 2;       // modifies the local copy, not the original
      print(n);
  }

  tantrum main()
  {
      int x = 5;
      double(x);       // prints 10
      print(x);        // still 5 â€” x was not modified
  }

  If you want to modify a value in the caller, use pointers:
  tantrum void double(int* p)
  {
      *p = *p * 2;     // modifies the actual value in memory
  }

  tantrum main()
  {
      int* x = alloc int(5);
      double(x);       // x's value is now 10
      print(*x);       // 10
      free x;
  }

================================================================================
  ADVANCED INFO: IMPORTS AND MULTI-FILE PROGRAMS
================================================================================

  As your programs grow, you'll want to split code across multiple files.
  Tantrums uses the `use` keyword for this.

  â”€â”€ BASIC IMPORT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  use helper.42AHH;

  This tells the compiler: read helper.42AHH, compile it, and bring all its
  functions and global variables into the current scope.

  If helper.42AHH defines:
  tantrum int square(int n) { return (n * n); }

  Then after `use helper.42AHH;`, you can call square() directly:
  print(square(7));    // 49

  â”€â”€ WHERE DO IMPORTED FILES LIVE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Currently, imported files must be in the same directory as the main file.
  The import resolution uses C++ std::ifstream with relative paths â€” it's not
  a sophisticated module resolver. If your files aren't in the same directory,
  the compiler will fail to find them and halt.

  A proper module search path system is planned for a future version.

  â”€â”€ CIRCULAR IMPORTS ARE SAFE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  The compiler maintains a list of all files it has already resolved. If file
  A imports file B, and file B imports file A, the compiler detects the circular
  dependency on the second import and skips it. You won't get infinite loops or
  stack overflows from circular imports.

  If file A imports file B and file B imports file C and file C imports file B
  again â€” still fine. The duplicate import of B is ignored.

  â”€â”€ THERE IS NO NAMESPACE ISOLATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Importing a file brings ALL of its functions into the current scope with no
  namespace prefix. If helper.42AHH and math.42AHH both define a function
  called calculate(), the second import wins and overwrites the first.

  This is a known limitation. Namespace isolation is planned but not yet
  implemented. For now, be deliberate about function names in imported files.

  â”€â”€ MULTI-FILE EXAMPLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // math_utils.42AHH
  tantrum int square(int n)
  {
      return (n * n);
  }

  tantrum float circle_area(float r)
  {
      return (3.14159 * square(r));
  }

  // main.42AHH
  use math_utils.42AHH;

  tantrum main()
  {
      print(square(5));           // 25
      print(circle_area(3.0));    // 28.27431
  }

================================================================================
  ADVANCED INFO: BUILT-IN FUNCTIONS
================================================================================

  These functions are always available. No import, no use statement, nothing.
  They are baked directly into the VM.

  â”€â”€ print(x) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Prints x to the console followed by a newline.

  print(42);                      // 42
  print("Hello");                 // Hello
  print(3.14);                    // 3.14
  print(true);                    // true
  print([1, 2, 3]);               // [1, 2, 3]
  print({"key": "value"});        // {key: value}
  print("Score: " + 100);        // Score: 100

  print handles every type. It auto-formats lists with brackets and commas,
  maps with braces and colons, and everything else as you'd expect.

  â”€â”€ input("prompt") â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Reads a line from the user and returns it. The return type depends on the
  type of variable you're assigning to, which is genuinely clever:

  x = input("Enter anything: ");          // returns raw string
  string s = input("Enter name: ");       // returns string
  int n = input("Enter a number: ");      // parses as integer
  float f = input("Enter a decimal: ");   // parses as float
  bool b = input("Yes or no? ");          // parses as boolean

  The bool parsing rules are a work of art (or madness, depending on your view):
  â€¢ "true" â†’ true
  â€¢ "false" â†’ false
  â€¢ Any letters or digits typed â†’ true
  â€¢ Just pressing Enter, spaces, or tabs â†’ false

  The logic is: if you typed something recognizable, you meant yes. If you
  pressed Enter without typing anything real, you meant no. It's lazy input
  validation taken to a philosophical extreme. It works for simple yes/no prompts.

  â”€â”€ len(x) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Returns the number of elements in a string, list, or map.

  len("Hello")       â†’ 5
  len([1, 2, 3])     â†’ 3
  len({"a": 1})      â†’ 1
  len("")             â†’ 0
  len([])             â†’ 0

  O(1) for all types. The length is stored with the data structure, not computed
  by counting. len() on a 1,000,000 element list is the same speed as on an
  empty list.

  â”€â”€ range() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Generates a sequence of integers. Three forms:

  range(end)               â†’ [0, 1, 2, ..., end-1]
  range(start, end)        â†’ [start, start+1, ..., end-1]
  range(start, end, step)  â†’ [start, start+step, ..., < end]

  Examples:
  range(5)           â†’ [0, 1, 2, 3, 4]
  range(2, 7)        â†’ [2, 3, 4, 5, 6]
  range(0, 20, 5)    â†’ [0, 5, 10, 15]
  range(10, 0, -2)   â†’ [10, 8, 6, 4, 2]   (negative step works)

  In for loops, range doesn't actually allocate a full list in memory. The
  compiler generates optimized bytecode that initializes a counter, checks it
  against the end value, and increments it at the end of each iteration. This
  is why looping with range(100000000) doesn't require a 100M element list.

  â”€â”€ type(x) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Returns the type name of x as a string.

  type(42)         â†’ "int"
  type(3.14)       â†’ "float"
  type("hello")    â†’ "string"
  type(true)       â†’ "bool"
  type([1, 2, 3])  â†’ "list"
  type({"k": "v"}) â†’ "map"

  Under the hood, this is a C++ switch statement over the Value's type enum
  returning a static string literal. It's very fast. There's no reflection or
  runtime introspection happening â€” just a lookup.

  â”€â”€ append(list, value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Appends value to the end of list. Mutates the list in place.

  list nums = [1, 2, 3];
  append(nums, 4);
  append(nums, 5);
  print(nums);    // [1, 2, 3, 4, 5]

  Internally, lists use a dynamic array with geometric capacity doubling. When
  the list runs out of space, it allocates a new buffer twice the size and
  copies everything over. This gives O(1) amortized append performance.

  â”€â”€ TIMING FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  getCurrentTime()
  Returns the current Unix epoch timestamp in milliseconds as an integer.
  Taps into C++'s <chrono> library for precision.

  toSeconds(ms)         â†’ float: milliseconds to seconds
  toMilliseconds(ms)    â†’ float: milliseconds to milliseconds (formatting)
  toMinutes(ms)         â†’ float: milliseconds to minutes
  toHours(ms)           â†’ float: milliseconds to hours

  Usage pattern for benchmarking:
  int start = getCurrentTime();
  // ... your code here ...
  int end = getCurrentTime();
  print("Elapsed: " + toSeconds(end - start) + " seconds");

  â”€â”€ MEMORY PROFILING FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  getProcessMemory()
  Returns the Resident Set Size (RSS) of the Tantrums process in bytes.
  RSS is how much actual physical RAM your process is using right now.
  This number includes the VM itself, your variables, and everything else.

  getVmMemory()
  Returns how many bytes the Tantrums VM has allocated internally for
  your program's data structures. This is a subset of process memory â€”
  just the part the VM manages.

  getVmPeakMemory()
  Returns the highest value getVmMemory() has ever returned during this
  execution. Useful for finding memory usage peaks without continuous sampling.

  bytesToKB(bytes)   â†’ float
  bytesToMB(bytes)   â†’ float
  bytesToGB(bytes)   â†’ float

  Full profiling example:
  tantrum main()
  {
      int start = getCurrentTime();
      int start_ram = getProcessMemory();

      list data = [];
      for i in range(100000) { append(data, i); }

      int end = getCurrentTime();
      int end_ram = getProcessMemory();

      print("Time: " + toSeconds(end - start) + "s");
      print("RAM used: " + bytesToMB(end_ram - start_ram) + " MB");
      print("Peak VM: " + bytesToMB(getVmPeakMemory()) + " MB");
  }

================================================================================
  LAUGHS & FACTS: THE WEIRD STUFF
================================================================================

  ðŸ“ž THE CALL FRAME CAP
  The call stack is capped at 16,384 frames. This sounds like a lot, and it
  usually is. But if you write a naive recursive Fibonacci for the 30th number,
  you'll generate roughly 2.7 million function calls. That exceeds the limit
  by a factor of 165. Use loops for recursive patterns. The VM will thank you
  by not panicking.

  ðŸ“ž INPUT'S MAGICAL TYPE INFERENCE
  The input() function knowing what type to return based on the variable you're
  assigning to is not magic â€” it's the compiler being sneaky. During type
  checking, when the compiler sees `int n = input("...")`, it emits a special
  version of the input opcode that tells the VM: "parse this as int." There's
  literally a different bytecode instruction for each input type. It's not
  reflection â€” it's pre-computed type dispatch at compile time.

  ðŸ“ž THE PRINT VIP STORY
  Early in development, print() was literally special-cased inside the main
  VM execution loop. While every other function goes through: push frame,
  resolve locals, execute body, pop frame â€” print() was intercepted before
  any of that and handled directly in the switch case. It was a temporary
  hack. It survived for much longer than intended. It has since been properly
  integrated into the built-in function dispatch system, but its legacy
  lives on in the hearts of those who knew it as the VIP bouncer.

  ðŸ“ž NO ANONYMOUS FUNCTIONS
  You can't write `x = tantrum() { return (42); }` or any kind of lambda.
  Every function needs an explicit name. The parser was built around the pattern
  of `tantrum IDENTIFIER (...)` and adding anonymous function support would
  require significantly rethinking the parsing strategy. It's on the roadmap.
  Until then, if you want a "lambda," just name it something and define it above.

  ðŸ“ž NO TAIL-CALL OPTIMIZATION
  Some languages (Scheme, Haskell, some versions of JavaScript) optimize
  tail-recursive calls so they don't consume extra stack frames. Tantrums
  currently doesn't. Every recursive call creates a new frame. If you use
  recursion for anything serious, you WILL eventually overflow the call stack.
  Convert to iteration. It's fine. Iteration is underrated.

  ðŸ“ž THE DUPLICATE IMPORT SKIP
  The circular import prevention works by maintaining a simple array of file
  paths that have been successfully resolved. Before compiling any imported
  file, the compiler checks this array. If the file is already in it, it skips
  the import silently. This means if you `use` the same file from 12 different
  places, it only gets compiled once. Fast. Simple. Not brilliant. Works.

================================================================================
  END OF FUNCTIONS. GO THROW SOME TANTRUMS.
  YOUR FUNCTIONS ARE WAITING TO BE DECLARED.
================================================================================