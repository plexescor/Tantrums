================================================================================
                      GETTING STARTED WITH TANTRUMS
================================================================================

  Welcome. You picked up a programming language that was built from scratch,
  in C++, without reading a single compiler textbook. That's either impressive
  or terrifying depending on your perspective. Either way, it compiles code and
  runs it fast, so let's get you set up.

  This guide covers:
  â€¢ What Tantrums actually is under the hood
  â€¢ How to build the compiler from source
  â€¢ The three CLI commands you'll use every day
  â€¢ Writing your first program
  â€¢ Understanding the full compilation pipeline
  â€¢ Things that happened during development that will make you laugh nervously

================================================================================
  BASIC INFO: WHAT IS TANTRUMS, EXACTLY?
================================================================================

  Tantrums is a compiled, bytecode-interpreted programming language. That means:

  1. You write .42AHH source files.
  2. The compiler reads them, validates them, and produces .42ass bytecode files.
  3. The virtual machine (VM) reads the .42ass file and executes your program.

  The .42ass bytecode is cross-platform. Compile on Windows, run on Linux.
  Compile on Linux, run on Mac. The VM is entirely abstract â€” it doesn't know
  or care what CPU is underneath it. If you have the Tantrums VM binary compiled
  for your OS, any .42ass file will run on it identically.

  The language has a C-like syntax with brace-delimited blocks { } because
  indentation-based syntax (like Python) is a trap. One misplaced tab and your
  entire program silently does the wrong thing. With braces, the compiler KNOWS
  exactly where your blocks start and end, and it will tell you when you forget
  to close one.

  The overall design sits somewhere between Python (flexible typing, easy syntax),
  C (manual memory control when you want it, fast execution), and something that
  just vibes. You'll see what we mean.

================================================================================
  BASIC INFO: PREREQUISITES
================================================================================

  Before you can write Tantrums code, you need to compile the Tantrums compiler
  itself. This is called "bootstrapping" and it sounds fancier than it is.

  You need:

  CMake 3.15 or higher
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  CMake is a build system generator. It reads the CMakeLists.txt file in the
  Tantrums project root and generates the actual build files for your platform
  (Makefiles on Linux, Visual Studio project files on Windows, etc.).

  Download from: https://cmake.org/download/

  A C++23 Compatible Compiler
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Any of these will work:
  â€¢ MSVC (Visual Studio 2022 or later) â€” Windows
  â€¢ GCC 13+ â€” Linux / Mac / Windows
  â€¢ Clang 16+ â€” Any platform

  The project uses C++23 features, so older compilers will fail to build it.
  If you're on Windows and don't have a compiler, install Visual Studio 2022
  Community Edition (it's free) and make sure the "Desktop development with C++"
  workload is selected during installation.

================================================================================
  BASIC INFO: BUILDING THE COMPILER
================================================================================

  Step 1: Open your terminal (Command Prompt, PowerShell, bash, whatever you use)
  Step 2: Navigate to the root folder of the Tantrums project
  Step 3: Run this:

  cmake -B build -S .

  This tells CMake: "Read the CMakeLists.txt from the current directory (.) and
  put all your generated build files in a folder called 'build'." CMake will
  create the build directory automatically if it doesn't exist. You'll see it
  scan through your system finding your compiler, generating files, and
  generally doing its thing.

  Step 4: Run this:

  cmake --build build --config Release

  This actually compiles the C++ source code. It will take 10-60 seconds
  depending on your machine. You'll see progress output as it compiles each file.

  When it finishes, your compiler binary lives at:
  â€¢ Windows:    build\Release\tantrums.exe
  â€¢ Linux/Mac:  build/tantrums

  Step 5: Add that directory to your system PATH variable so you can just type
  `tantrums` from anywhere without specifying the full path every time.

  On Windows: Search "Environment Variables" in the Start menu, find the PATH
  variable, and add the full path to your build\Release folder.

  On Linux/Mac: Add this to your ~/.bashrc or ~/.zshrc:
  export PATH="$PATH:/path/to/tantrums/build"

  Then restart your terminal or run `source ~/.bashrc`.

  Step 6: Verify it worked:
  tantrums --help

  If you see a help message, you're done. Go write code.

  â”€â”€ A NOTE ON DEBUG VS RELEASE BUILDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  The --config Release flag matters more than you think. Debug builds include
  extra runtime assertions and zero optimization. The performance difference
  between Debug and Release is approximately 2x on raw execution speed.
  If you're benchmarking anything, always use the Release build.

  For development work on the Tantrums compiler itself, use:
  cmake --build build --config Debug

================================================================================
  BASIC INFO: THE THREE CLI COMMANDS
================================================================================

  Tantrums has three ways to run your code, each with a different use case.

  â”€â”€ COMMAND 1: tantrums run â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  tantrums run yourfile.42AHH

  This is the all-in-one command. It reads your source file, compiles it to
  bytecode in memory (without saving the .42ass file to disk), and immediately
  runs it on the VM. This is your go-to during development â€” one command,
  edit your file, run it again.

  Use this when: You're writing and testing code and don't care about keeping
  the compiled bytecode around.

  â”€â”€ COMMAND 2: tantrums compile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  tantrums compile yourfile.42AHH

  This compiles your source file to a .42ass bytecode file on disk, but does
  NOT run it. The bytecode file will appear in the same directory as your source
  file with the same name but a .42ass extension.

  Use this when:
  â€¢ You want to distribute your program without sharing the source code
  â€¢ You want to compile once and run many times (skips parsing overhead)
  â€¢ You're cross-compiling â€” building the bytecode on one machine to run on another

  â”€â”€ COMMAND 3: tantrums exec â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  tantrums exec yourfile.42ass

  This loads a pre-compiled .42ass file and runs it directly on the VM. It
  completely skips the lexing and parsing phases. The VM just reads the binary
  file and starts executing instructions.

  Use this when: You already compiled the bytecode and just want to run it
  without re-compiling. The startup time is noticeably faster because the
  lexer and parser aren't running.

  â”€â”€ FLAGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  --no-autofree-notes
  Suppresses the informational notes that the compiler prints when it
  automatically frees a provably local pointer. If you're using #autoFree true
  (the default) and don't want to see those notes, add this flag.

  tantrums run yourfile.42AHH --no-autofree-notes

================================================================================
  BASIC INFO: YOUR FIRST PROGRAM
================================================================================

  Create a new file called hello.42AHH and type exactly this:

  tantrum main()
  {
      print("Hello, World!");
  }

  Save it. Run it:

  tantrums run hello.42AHH

  You should see:
  Hello, World!

  Let's talk about what you just wrote.

  tantrum
  â”€â”€â”€â”€â”€â”€â”€â”€
  This is how you declare a function in Tantrums. Not `func`, not `def`, not
  `function`. You throw a `tantrum`. Every function you write starts with this
  keyword. It was chosen because when a programmer writes a function, they are
  essentially throwing a tantrum at the computer: "DO THIS THING. IN THIS ORDER.
  WITH THESE INPUTS. AND GIVE ME EXACTLY WHAT I EXPECT." That's a tantrum.

  main()
  â”€â”€â”€â”€â”€â”€â”€
  This is the entry point. When the VM starts executing your program, the first
  thing it does is search for a function named `main` and call it. If there's
  no `main()`, the VM will compile your code successfully, then stare at you
  blankly and do absolutely nothing. This is a known source of confusion for
  new users and the reason the VS Code extension has a specific warning for it.

  { }
  â”€â”€â”€â”€
  Curly braces define the body of the function. Everything between { and }
  is the code that runs when this function is called. Always put the opening
  brace on its own line. This is the style convention for Tantrums.

  print("Hello, World!")
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  print() is a built-in function. You don't need to import anything. It's always
  available. It prints whatever you give it to the console and moves to the
  next line. It handles strings, numbers, lists, maps, booleans â€” everything.

================================================================================
  ADVANCED INFO: THE COMPILATION PIPELINE
================================================================================

  When you type `tantrums run hello.42AHH`, a lot happens in milliseconds.
  Here's the full pipeline, from source code to output.

  â”€â”€ STAGE 1: THE LEXER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  The Lexer (also called a tokenizer) reads your .42AHH source file as raw text
  and breaks it into a sequence of tokens. A token is the smallest meaningful
  unit of code â€” a keyword, an identifier, an operator, a string literal, etc.

  For `tantrum main() { print("Hello, World!"); }`, the Lexer produces:
  TOKEN_TANTRUM
  TOKEN_IDENTIFIER("main")
  TOKEN_LEFT_PAREN
  TOKEN_RIGHT_PAREN
  TOKEN_LEFT_BRACE
  TOKEN_IDENTIFIER("print")
  TOKEN_LEFT_PAREN
  TOKEN_STRING("Hello, World!")
  TOKEN_RIGHT_PAREN
  TOKEN_SEMICOLON
  TOKEN_RIGHT_BRACE
  TOKEN_EOF

  The Lexer strips whitespace and comments completely. By the time the Parser
  sees the code, indentation, blank lines, and comments are gone. Only tokens
  remain. This is also where the file's directive declarations (#mode, #autoFree,
  #allowMemoryLeaks) are read and stored for later use.

  â”€â”€ STAGE 2: THE PARSER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  The Parser reads the token stream and builds an Abstract Syntax Tree (AST).
  The AST is a tree data structure that represents the logical structure of your
  program. Each node in the tree is a programming construct â€” a function
  declaration, a function call, a binary operation, a variable declaration, etc.

  Tantrums uses a recursive descent parser. This means the parser is a
  collection of mutually recursive functions. `parseFunctionDecl()` calls
  `parseBlock()`, which calls `parseStatement()`, which might call
  `parseExpression()`, which might call `parsePrimary()`, and so on.

  This is where syntax errors are caught. If you forget a closing brace or
  mistype a keyword, the parser detects it and reports the exact(mostly) line number.

  â”€â”€ STAGE 3: SEMANTIC ANALYSIS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  After the AST is built, the compiler does a semantic analysis pass. This is
  where the meaning of your code is checked, not just its syntax.

  Things checked during semantic analysis:
  â€¢ Type checking â€” does this function call get the right argument types?
  â€¢ Variable resolution â€” is this variable actually declared?
  â€¢ Escape analysis â€” for every alloc'd pointer, does it escape the scope?
  â€¢ Return type enforcement â€” in #mode static, do all code paths return?
  â€¢ Directive consistency â€” is #allowMemoryLeaks true paired with #autoFree false?

  If the mode is #mode both or #mode static, the type checker walks the AST
  validating every typed variable assignment and function argument. If you
  pass a string to a parameter declared as int, the compiler refuses to compile
  and tells you exactly which line has the problem.

  â”€â”€ STAGE 4: CODE GENERATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  The compiler walks the validated AST and emits bytecode instructions. Each
  AST node maps to one or more VM opcodes.

  For example, `print("Hello, World!")` generates something like:
  OP_CONSTANT 0         ; load the string "Hello, World!" from the constant pool
  OP_GET_GLOBAL "print" ; look up the print built-in
  OP_CALL 1             ; call it with 1 argument
  OP_POP                ; discard the return value

  If #autoFree is true, the code generator also injects OP_FREE instructions
  at the end of scopes for pointers that were determined to be provably local
  during escape analysis. These injected frees are transparent â€” they work
  exactly like if you had written free p; yourself.

  The directive flags (#autoFree, #allowMemoryLeaks) are also baked into the
  binary header of the .42ass file during this stage. When the VM loads the
  bytecode later, it reads these flags from the header and configures itself
  accordingly. This is how #autoFree false disables runtime auto-free even
  without the source file being present.

  â”€â”€ STAGE 5: THE VIRTUAL MACHINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  The VM is a stack-based interpreter. It maintains:

  â€¢ An operand stack â€” where values live during computation
  â€¢ A call frame stack â€” one frame per active function call, up to 16,384 deep
  â€¢ A global variable table â€” for globally-scoped variables and functions
  â€¢ A live pointer registry â€” tracking every alloc'd pointer for safety checks

  The main execution loop is a massive switch statement running inside a while
  loop. It reads the next opcode, dispatches to the handler for that opcode,
  executes it, and loops. This loop runs millions of times per second.

  When the VM reads your .42ass file, it first reads the header flags to
  configure itself (auto-free on/off, leak detection behavior, etc.), then
  loads the constant pool (strings, numbers, function names), then enters the
  main execution loop.

  When execution finishes (main() returns), the VM runs the exit leak detector
  before shutting down. Any alloc'd pointers that were never freed, never
  auto-freed, and not suppressed by #allowMemoryLeaks are reported with their
  allocation line numbers, types, and sizes.

================================================================================
  ADVANCED INFO: THE BYTECODE FILE FORMAT
================================================================================

  The .42ass binary format is Tantrums' own custom format. It's not ELF, not
  WASM, not JVM class files. It's our own thing.

  The structure:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ HEADER                                          â”‚
  â”‚  â€¢ Magic bytes (identifies it as a .42ass file) â”‚
  â”‚  â€¢ Version number                               â”‚
  â”‚  â€¢ #autoFree flag (0 or 1)                      â”‚
  â”‚  â€¢ #allowMemoryLeaks flag (0 or 1)              â”‚
  â”‚  â€¢ #mode flag (static/dynamic/both)             â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ CONSTANT POOL                                   â”‚
  â”‚  â€¢ All string literals, numbers, function names â”‚
  â”‚  â€¢ Each constant is indexed â€” opcodes reference â”‚
  â”‚    them by index rather than embedding the data â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ BYTECODE                                        â”‚
  â”‚  â€¢ Raw unsigned 8-bit opcodes                   â”‚
  â”‚  â€¢ Operands follow each opcode that needs them  â”‚
  â”‚  â€¢ Function bodies follow one after another     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  The format is intentionally simple. No compression, no encryption, no metadata
  beyond what's needed to run the program. This keeps the VM's loader fast and
  the format easy to reason about.

================================================================================
  LAUGHS & FACTS: THINGS THAT WENT WRONG DURING DEVELOPMENT
================================================================================

  ğŸ’¥ THE EOF VARIABLE BUG
  During Lexer development, a bug caused the End-Of-File token to be treated
  as an actual variable name. The VM tried to allocate memory for a variable
  literally named "EOF" and segfaulted. It took 3 hours to figure out why empty
  files were crashing the compiler. The fix was two lines of code.

  ğŸ’¥ THE MISSING MAIN DISCOVERY
  Originally, scripts could float in global scope like Python â€” no main()
  required. This was removed because managing local variable scopes in global
  space made the compiler logic genuinely horrible. After the change, users
  started complaining their code "wasn't running" because it compiled but then
  did nothing. A VS Code diagnostic named "NO MAIN FUNC missing wrapper
  detection" had to be added. The name was not changed. It remains exactly that.

  ğŸ’¥ THE PRINT VIP ACCESS
  In early development, print() was literally special-cased directly inside
  the main VM execution loop. While every other function goes through the full
  call mechanism (push frame, resolve arguments, execute body, pop frame),
  print() was intercepted before any of that and handled directly. It had
  exclusive access to the internal VM stack. It was the bouncer AND the VIP.
  This was a temporary hack that survived for much longer than intended.

  ğŸ’¥ THE 32GB RAM INCIDENT
  A test script that created a self-referencing map inside a while(true) loop
  consumed all 16GB of physical RAM plus 16GB of page file before requiring
  a hard system reboot. The reference cycle collector was implemented
  approximately immediately after. No data was lost. The test machine was fine.
  The developer's blood pressure was less fine, Anthropic's server thanked us for 
  not stressing them for the period the test machine was off.

  ğŸ’¥ THE PORTABLE BYTECODE COINCIDENCE
  The bytecode being cross-platform was partly intentional and partly a happy
  accident. Because the VM is entirely abstract (it has no concept of real
  memory addresses, CPU registers, or OS-specific anything), the bytecode just
  works everywhere. We could have claimed this was a deliberate architectural
  decision. We're choosing honesty instead.

  ğŸ’¥ THE COMPILER-OF-A-COMPILER MOMENT
  The first time someone realized they needed to compile the compiler before
  they could compile their own code, there was a moment of existential confusion.
  This is called bootstrapping and it's completely normal. It is genuinely funny
  every time someone encounters it for the first time.

================================================================================
  QUICK START CHECKLIST
================================================================================

  â˜ Install CMake 3.15+
  â˜ Install a C++23 compiler (Visual Studio 2022 / GCC 13+ / Clang 16+)
  â˜ Run: cmake -B build -S .
  â˜ Run: cmake --build build --config Release
  â˜ Add tantrums to your PATH
  â˜ Run: tantrums --help (verify it works)
  â˜ Install the VS Code extension from tantrums-vscode/
  â˜ Create hello.42AHH with tantrum main() { print("Hello, World!"); }
  â˜ Run: tantrums run hello.42AHH
  â˜ See output. Feel accomplished.
  â˜ Read the rest of the documentation.

================================================================================
  END OF GETTING STARTED. YOUR COMPILER IS READY. GO BREAK THINGS.
================================================================================